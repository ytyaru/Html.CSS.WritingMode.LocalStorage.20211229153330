# 0.38 余白を実装する（仮実装。段組みバグを解消した）

　基本的に段組は画面比率100vw,vhから段組数で割る。

```css
block-size: 100(画面全体);
inline-size: 100(画面全体) / 段組数;
```

　`block-size`,`inline-size`で指定する。これは`width`,`height`と同じだが`writing-mode`によって適時変更される論理プロパティである。

CSSプロパティ|概要
-------------|----
`block-size`|段落方向（横書きなら`height`、縦書きなら`width`）
`inline-size`|文字方向（横書きなら`width`、縦書きなら`height`）

　問題は画面比率の指定だ。`writing-mode`によって適切に変更してくれるため、そこはJSで動的に変更せずに済む。だが画面比率`100vw`,`100vh`における論理プロパティ値はない。`100%`という指定もできるが、画面サイズではなく内容サイズのためスクロール分も含まれてしまう。結局、画面比率の値だけはJSで`writing-mode`変更時に動的変更してやらねばならない。

```css
block-size: calc(var(--block-size-base));
inline-size: calc(var(--inline-size-base) - calc(var(--column-gap-em) * 1em));
```
```javascript
const UNIT_BLOCK = 'v' + ((IS_VERTICAL) ? 'w' : 'h');
const UNIT_INLINE = 'v' + ((IS_VERTICAL) ? 'h' : 'w');
root.style.setProperty('--block-size-base', '100' + UNIT_BLOCK);
root.style.setProperty('--inline-size-base', `${(100 / columns)}${UNIT_INLINE}`);
```

style.css
```css
:root{
    --column-gap-em:1;
    --block-size-base:100vh; /* holizontal-tb:100vh, vertical-rl:100vw */
    --inline-size-base:100vw; /* holizontal-tb:100vw, vertical-rl:100vh */
}
body {
    block-size: calc(var(--block-size-base));
    inline-size: calc(var(--inline-size-base) - calc(var(--column-gap-em) * 1em));
}
```
resize.js
```javascript
function calcScreenSize(writingMode, columns) { // 画面比率を変える（writingModeと段組数に応じて）
    const IS_VERTICAL = ('vertical-rl' === writingMode);
    /*
    const FULL_ID = (IS_VERTICAL) ? '--width-vw' : '--height-vh' ;
    const SPLIT_ID = (IS_VERTICAL) ? '--height-vh' : '--width-vw' ;
    document.querySelector(':root').style.setProperty(FULL_ID, 100);
    document.querySelector(':root').style.setProperty(SPLIT_ID, 100 / columns); // 段組み数で割る
    */
    // inline側が分割される（横書きなら横、縦書きなら縦に段組みされる）
    const root = document.querySelector(':root');
    const UNIT_BLOCK = 'v' + ((IS_VERTICAL) ? 'w' : 'h');
    const UNIT_INLINE = 'v' + ((IS_VERTICAL) ? 'h' : 'w');
    function getUnitBlock() { 'v' + ((IS_VERTICAL) ? 'w' : 'h'); }
    function getUnitInline() { 'v' + ((IS_VERTICAL) ? 'h' : 'w'); }
    root.style.setProperty('--block-size-base', '100' + UNIT_BLOCK);
    root.style.setProperty('--inline-size-base', `${(100 / columns)}${UNIT_INLINE}`);
    // 段組余白（WritingModeに応じてセットする。横書きなら横、縦書きなら縦に。それ以外はゼロ）
    const COL_GAP_EM = parseFloat(getComputedStyle(document.querySelector(':root')).getPropertyValue('--column-gap-em')) || 1;
    root.style.setProperty(`--column-gap-em-${(IS_VERTICAL) ? 'w' : 'h'}`, 0); // FULL
    root.style.setProperty(`--column-gap-em-${(IS_VERTICAL) ? 'h' : 'w'}`, COL_GAP_EM); // SPLIT
    console.log(`--block-size-base:${getComputedStyle(document.querySelector(':root')).getPropertyValue('--block-size-base')}`);
    console.log(`--inline-size-base:${getComputedStyle(document.querySelector(':root')).getPropertyValue('--inline-size-base')}`);
    console.log(`block-size:${getComputedStyle(document.querySelector('body')).getPropertyValue('block-size')}`);
    console.log(`inline-size:${getComputedStyle(document.querySelector('body')).getPropertyValue('inline-size')}`);
}
```

