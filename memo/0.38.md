# 0.38 余白を実装する（仮実装。段組みバグを解消した）

1. 仮実装。段組みバグを解消した
2. CSSで余白を入れたが、フォントサイズ計算に反映されていないためズレている
3. フォントサイズ計算＋CSS余白（inline方向の余白はbody内要素に対してセットすべきだった）

## 1. 仮実装。段組みバグを解消した

　基本的に段組は画面比率100vw,vhから段組数で割る。

```css
block-size: 100(画面全体);
inline-size: 100(画面全体) / 段組数;
```

　`block-size`,`inline-size`で指定する。これは`width`,`height`と同じだが`writing-mode`によって適時変更される論理プロパティである。

CSSプロパティ|概要
-------------|----
`block-size`|段落方向（横書きなら`height`、縦書きなら`width`）
`inline-size`|文字方向（横書きなら`width`、縦書きなら`height`）

　問題は画面比率の指定だ。`writing-mode`によって適切に変更してくれるため、そこはJSで動的に変更せずに済む。だが画面比率`100vw`,`100vh`における論理プロパティ値はない。`100%`という指定もできるが、画面サイズではなく内容サイズのためスクロール分も含まれてしまう。結局、画面比率の値だけはJSで`writing-mode`変更時に動的変更してやらねばならない。

```css
block-size: calc(var(--block-size-base));
inline-size: calc(var(--inline-size-base) - calc(var(--column-gap-em) * 1em));
```
```javascript
const UNIT_BLOCK = 'v' + ((IS_VERTICAL) ? 'w' : 'h');
const UNIT_INLINE = 'v' + ((IS_VERTICAL) ? 'h' : 'w');
root.style.setProperty('--block-size-base', '100' + UNIT_BLOCK);
root.style.setProperty('--inline-size-base', `${(100 / columns)}${UNIT_INLINE}`);
```

style.css
```css
:root{
    --column-gap-em:1;
    --block-size-base:100vh; /* holizontal-tb:100vh, vertical-rl:100vw */
    --inline-size-base:100vw; /* holizontal-tb:100vw, vertical-rl:100vh */
}
body {
    block-size: calc(var(--block-size-base));
    inline-size: calc(var(--inline-size-base) - calc(var(--column-gap-em) * 1em));
}
```
resize.js
```javascript
function calcScreenSize(writingMode, columns) { // 画面比率を変える（writingModeと段組数に応じて）
    const IS_VERTICAL = ('vertical-rl' === writingMode);
    /*
    const FULL_ID = (IS_VERTICAL) ? '--width-vw' : '--height-vh' ;
    const SPLIT_ID = (IS_VERTICAL) ? '--height-vh' : '--width-vw' ;
    document.querySelector(':root').style.setProperty(FULL_ID, 100);
    document.querySelector(':root').style.setProperty(SPLIT_ID, 100 / columns); // 段組み数で割る
    */
    // inline側が分割される（横書きなら横、縦書きなら縦に段組みされる）
    const root = document.querySelector(':root');
    const UNIT_BLOCK = 'v' + ((IS_VERTICAL) ? 'w' : 'h');
    const UNIT_INLINE = 'v' + ((IS_VERTICAL) ? 'h' : 'w');
    function getUnitBlock() { 'v' + ((IS_VERTICAL) ? 'w' : 'h'); }
    function getUnitInline() { 'v' + ((IS_VERTICAL) ? 'h' : 'w'); }
    root.style.setProperty('--block-size-base', '100' + UNIT_BLOCK);
    root.style.setProperty('--inline-size-base', `${(100 / columns)}${UNIT_INLINE}`);
    // 段組余白（WritingModeに応じてセットする。横書きなら横、縦書きなら縦に。それ以外はゼロ）
    const COL_GAP_EM = parseFloat(getComputedStyle(document.querySelector(':root')).getPropertyValue('--column-gap-em')) || 1;
    root.style.setProperty(`--column-gap-em-${(IS_VERTICAL) ? 'w' : 'h'}`, 0); // FULL
    root.style.setProperty(`--column-gap-em-${(IS_VERTICAL) ? 'h' : 'w'}`, COL_GAP_EM); // SPLIT
    console.log(`--block-size-base:${getComputedStyle(document.querySelector(':root')).getPropertyValue('--block-size-base')}`);
    console.log(`--inline-size-base:${getComputedStyle(document.querySelector(':root')).getPropertyValue('--inline-size-base')}`);
    console.log(`block-size:${getComputedStyle(document.querySelector('body')).getPropertyValue('block-size')}`);
    console.log(`inline-size:${getComputedStyle(document.querySelector('body')).getPropertyValue('inline-size')}`);
}
```

## 2. CSSで余白を入れたが、フォントサイズ計算に反映されていないためズレている

```css
```

## 3. フォントサイズ計算＋CSS余白（inline方向の余白はbody内要素に対してセットすべきだった）

　`block`方向の余白はCSSで計算する。フォントサイズ計算に必要な余白は`inline`方向のみである。

```css
body {
    block-size: calc(var(--block-size-base) - calc(var(--margin-block-start-em) * 1em) - calc(var(--margin-block-end-em) * 1em) - calc(var(--p-margin-block-end-em) * 1em));
    inline-size: calc(var(--inline-size-base));

    margin-block-start: calc(var(--margin-block-start-em) * 1em);  
    margin-block-end: calc(var(--margin-block-end-em) * 1em);
}
```
```css
p {
    /* 段落ごとの改行。でもこれって字下げと同じでプレーンテキストで再現すべきことでは？　HTMLだと<br>か？ */
    margin-block-end: calc(var(--p-margin-block-end-em) * 1em);

    /* 画面全体におけるマージンのinline方向版。bodyにセットしてもうまくいかないのでbody直下の要素に対してセットする。 */
    margin-inline-start: calc(var(--margin-inline-start-em) * 1em);
    margin-inline-end: calc(var(--margin-inline-start-em) * 1em);
}
```
resize.js
```javascript
    const MARGIN_EM = cssF('--margin-inline-start-em') + cssF('--margin-inline-end-em');
    const fontSizePx = LINE_OF_PX / ((lineOfChars * (1 + letterSpacing)) + (COL_GAP_EM / 2) + MARGIN_EM);
```
```javascript
function calcFontSizePixel(writingMode, lineOfChars, letterSpacing) { // フォントサイズをピクセル単位で算出する
    function cssF(key) { return parseFloat(getComputedStyle(document.querySelector(':root')).getPropertyValue(key)); }
    const IS_VERTICAL = ('vertical-rl' === writingMode);
    const LINE_OF_PX = (IS_VERTICAL) ? document.body.clientHeight : document.body.clientWidth; // １行の表示領域
//    const COL_GAP_EM = parseFloat(getComputedStyle(document.querySelector(':root')).getPropertyValue('--column-gap-em'));
    const COL_GAP_EM = cssF('--column-gap-em');
    const MARGIN_EM = cssF('--margin-inline-start-em') + cssF('--margin-inline-end-em');
    const fontSizePx = LINE_OF_PX / ((lineOfChars * (1 + letterSpacing)) + (COL_GAP_EM / 2) + MARGIN_EM);
//    const fontSizePx = LINE_OF_PX / ((lineOfChars * (1 + letterSpacing)) + (COL_GAP_EM / 2));
    console.log(`フォントサイズ:${fontSizePx}px`);
    console.log(`LINE_OF_PX:${LINE_OF_PX}px`);
    console.log(`letterSpacing:${letterSpacing}em`);
    console.log(`lineOfChars :${lineOfChars }字`);
    return fontSizePx;
}
```
