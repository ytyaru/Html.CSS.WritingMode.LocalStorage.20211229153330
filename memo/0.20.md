# 段組み領域を1画面サイズにしたい

　現状だと段組みは全テキスト単位で分割されてしまう。そのためスクロール末端まで読んだら、その後はスクロール先端まで戻らねばならない。その作業が段組数だけ必要である。これだと手間がかかりすぎて面倒だ。

　そこで段組みの仕方を変えたい。本と同じようにしたい。１画面サイズに含められる字数分だけ字をぶちこんで、そこを１つの段組みとする。そんなことがCSSで実現できるか不明なのでやってみる。`column-width:100%;`の状態でやればイケるかもしれない。他にも`break-after: column;`の動作を確認したい。

（`column-width:`, `width`, `height`, `column-gap`, `column-rule-width`, `break-after: column;`）

* https://developer.mozilla.org/ja/docs/Web/CSS/CSS_Columns
* https://developer.mozilla.org/ja/docs/Web/CSS/column-width

## column-width

　段組み1段あたりの領域を画面サイズと同じにする。概ね本のような表示になった。しかし次のような問題点がある。ひとことでいうなら「１画面単位での段組みができない」ということだろう。

* ページ送りが本のようにならない
    * 横書き：横スクロールのためマウスホイールでスクロールできない
    * 縦書き：縦スクロールのためマウスホイールでスクロールできるが、中途半端な位置になりぴったり次ページをすべて表示刷る位置にならない
* 見切れてしまう（ルビの部分など一部がページの前後をまたいでしまう）

縦書き
```css
    writing-mode: vertical-rl;
    text-orientation: var(--text-orientation); /* upright, sideways */

    --client-width:calc((1920 - 20) * 1px);
    --client-height:calc((1080- 80) * 1px);
    width: var(--client-width);
    height: var(--client-height);
    column-width: var(--client-width);
    column-gap: calc(var(--column-gap-px) * 1px);
    column-rule: thick inset black; /* 段組み装飾 */
```

横書き
```css
    writing-mode: horizontal-tb;
    text-orientation: var(--text-orientation); /* upright, sideways */

    --client-width:calc(1920 - 20);
    --client-height:calc(1080 - 150);
    width: calc(var(--client-width)*1px);
    height: calc(var(--client-height)*1px);
    column-width: calc((var(--client-width))*1px);
    column-gap: calc(var(--column-gap-px) * 1px);
    column-rule: thick inset black; /* 段組み装飾 */
```

　段組みの具切りはあくまでピクセル単位での領域。なのでHTML要素が見切れていようがお構いなし。ひどい。

## `break-after: column;`

　上記の失敗を踏まえ、HTML要素単位で区切りたい。けれど画面サイズ領域も考慮したい。つまりHTML要素のうち見きれずにすべて表示できている最後の要素を探し、その要素に`break-after: column;`を適用する。これにてHTML要素（パラグラフ単位）で改ページ（改段落）できるはず。

　想定されるバグとしてはレスポンスの悪化だ。上記計算をするのはかなりの負荷がかかるはず。一気にすべてやるならHTML要素数が多いほど時間がかかる。次の要素だけやるなら少なくて済むが、ページをジャンプすることができなくなる。ページジャンプしたいときにはじめて計算してもいいが、やはりレスポンスが遅いだろう。

* https://developer.mozilla.org/ja/docs/Web/CSS/break-after

### 方法

　画面サイズに応じて改ページ（改段組み）するHTML要素を見つけ出してbreak-after: column;する。

### 計算方法

1. HTML要素を先頭から順に見てゆく
2. 1を表示する幅（高さ）をCSSピクセル単位で取得する
3. 2を次々に加算してゆく
4. 3が画面サイズを超過したとき、直前の要素に対してbreak-after: column;する
5. 3の値を0に戻し、現在のHTML要素から再び1を繰り返す。これを最後の要素まで繰り返す。

### 結果

#### 縦書き

　失敗。再描画されないせい。HTMLのstyle属性値に`break-after: column;`をセットした。それはデベロッパツールで成功したことを確認した。けれど画面の表示は変わらなかった。なんでや！

　あとは`.break{break-after: column;}`のようにCSS定義し、HTML要素のclass属性値に`class="break"`としてみる。これでもダメならお手上げ。ブラウザ側実装の問題だと思われる。

　と思ったが、それはデベロッパツール画面のバグっぽい。ちゃんとbreakした。けれどルビが次の段組みにまがたり中途半端に見切れてしまう問題は相変わらず健在。なんでや！　デベロッパツールのON/OFFを切り替えると見切れなくなる。でもそれをしないと見切れてしまう。再描画する必要があるってことか？　そこでリサイズイベントをぶちこんでみる。


```javascript
$(window).trigger('resize');
```
```javascript
    window.dispatchEvent(new Event('resize'));
    window.document.dispatchEvent(new Event('resize'));
```

* https://www.webdevqa.jp.net/ja/javascript/chrome-mac%E3%81%A7dom%E3%81%AE%E5%86%8D%E6%8F%8F%E7%94%BB%E6%9B%B4%E6%96%B0%E3%82%92%E5%BC%B7%E5%88%B6%E3%81%99%E3%82%8B/940986152/

　けれど変わらずダメ。

　`F11`キーで全画面表示ON/OFFをしたら見切れがなくなり成功した。やはり再描画していないことが直接の原因だと思われる。困った。再描画させるAPIは`resize`くらい。全画面APIもあるがこれはJSで実行するとエラーになって実行されない仕様。なので`resize`イベントをトリガーしても再描画されないなら、もはや打つ手がない。ぐぬぬ！

　以下のようにすると再描画された！

```javascript
    document.querySelector('body').style.display = 'inline';
```

　値は`none`だと非表示になってしまうし、`block`だとダメ。多分もとの値から変更があったら再描画されるのだろう。`body`はきっと`block`なんじゃない？　それを`inline`に変更したから再描画の必要性が出たと判断して再描画されたのだと思う。

　「吾輩は猫である」がたくさん書いてあるところと、次のパラグラフとの間でブレークする。でも、次のパラグラフのルビが両方の段組みにまたがって見切れてしまっている。そのスクロール位置でリロードすると、最初は見切れているが、１秒後くらいに改ページ（改段落）されて見切れなくなる。たぶんそのときに上記再描画イベントがトリガーされたということなのだろう。

　計算がおわり再描画されるまでの間は見切れてしまう。それが気持ち悪い。でも、このあたりが妥協点か。このように計算すれば時間はかかるものの、画面サイズが変わってもそれに合わせて改ページしてくれるため重宝するだろう。

#### 横書き

　縦書きは成功したのに横書きは失敗する。

　計算式を変えねばならない。再描画も以下ではダメで`inline`だとなぜか段組みが消えてしまう。`block`に変えると成功するっぽいが、見切れてしまう。

```javascript
    document.querySelector('body').style.display = 'inline';
```

#### `break`

　ページ、段、領域の区切り位置とその区切り方を指定する。

`break`|位置
-------|----
`before`|この要素と直前要素の間で区切りたいときに使う
`after`|この要素と直後要素の間で区切りたいときに使う
`inside`|区切り禁止する要素に使う

# 未解決問題

* 無駄な余白が大きくなってしまいがち。原因は`break`する単位が`p`要素だから。
* もし`p`要素ひとつで画面サイズを超過したら見切れてしまう場合がある（`p`要素単位で区切るから。`p`要素は段落であり数百字入りうるため十分起こりうる）

## 解決案

　文や`span`,`ruby`要素単位で区切るには以下。

1. `p`要素単位で画面サイズ超過する要素を抜き出す
1. 1の中にある要素を解析する（テキストノード、`span`、`ruby`）
1. 2のうちテキストノードは１文あたり`span`で囲む（`。`文字または改行の単位で）
1. 1の中にある要素のうち画面サイズ超過する要素を抜き出す
1. 4に`break`を仕込む

　なお、本と同じようにするなら文字単位、単語単位のようにさらに細かい単位で`break`したい。そうなると形態素解析が必要になり、負荷がはねあがる。ただでさえ`p`要素単位だけでも負荷が高いのに、これ以上負荷をあげると応答速度が絶望的に遅くなってしまう。

　現状、55KBのHTMLに対して`p`要素単位で区切る処理をすると2秒くらい時間がかかる。人が我慢できる限界は2秒と言われている。べつにホワイトアウトしているわけではないため、一応文字はみえている。ただ、計算が終わったあとで見切れていた要素が次ページへいくため、その移動して消える瞬間がみえてしまうことがある。かっこ悪い。

　HTML要素に直接書き込んで計算しないようにすればいいが、そうなると固定の画面サイズにしか適切に区切ることができない。ほかのサイズだとめちゃくちゃな場所で改ページされてしまう。予め主要な画面サイズには直接breakを仕込んだHTMLパターンをいくつか用意しておくか？　その作業負担がデカすぎる。

　よって現状、`p`要素単位で区切ることで妥協する。
