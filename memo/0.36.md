# 0.36 現在ページ位置をp要素位置換算する（バグ修正：スクロール途中でWritingModeを変更したら先頭に戻ってしまう問題）

## 必要箇所

* WritingMode変更時に同じ箇所を表示する
* 前回終了時復元
* 栞（bookmark）

## 方法

1. `WritingMode`変更時、`unload`時、栞を挟む／開くときに以下を実行する
2. HTML文書全体から`p`要素一覧を取得する
3. 2の要素にidを付与する:`p-${index}`
4. 画面先頭にある`p`要素の`index`を取得する:`const headElement = document.elementFromPoint(x,y)`
5. 4の要素の`id`属性値を取得する: `const headElementId = headElement.getAttribute('id')`
6. `WritingMode`変更時なら変更する。`unload`時や栞を挟むなら`localStorage.setItem`する。
7. 4の要素へスクロールする: `document.querySelector(`#${headElementId}`).scrollIntoView(true)`

## 課題

* 画面先頭要素
* 永続化

### 画面先頭要素

　起点となるのは画面先頭要素である。そのため、画面終端まですべて読了済みの場合、また調整するハメになる。たとえば横書きよりも縦書きのほうが多くの字数が入る。そこで縦書きから横書きにすると、縦書きでは１ページでおさまっていたテキストが、横書きでは２ページ以上にまたがってしまう。すると縦書きから横書きにしたあと、縦書き時の画面末尾要素に至るまで何度かページ遷移せねばならない。

　この問題は解決不能である。それでも画面先頭要素を起点にするのがもっとも合理的である。もし、先頭ではなく画面末尾要素を起点としてしまったら、未読箇所をすっとばしてしまう恐れがある。よって画面先頭要素を起点にするほうがマシだ。

　解決はできないが、改善案はある。ただ、どれも直感的に理解しづらい。なので今回実装したとおり画面先頭要素を起点とする方法で妥協するのがマシだと思われる。

* 先頭要素を起点としつつ、末尾要素を目立つように表示する（WritingMode変更前ではどこまで表示されていたかがわかる。ただし複数ページにまたがっている恐れがあるため確認にはページ遷移操作が必要な場合がある。また、目立つ表示などしたら邪魔になる。いつまで表示するかも考えねばならず、自動削除する実装も必要になり、面倒くさい。本にはない機能だし直感的に理解しづらい）
* クリックしたp要素を起点とする（画面端クリックはページ遷移や設定表示に使われるため指定できない。まあその場合は画面端なので先頭要素を起点とした方法でやればいいか。それでも「p要素選択」という新たな処理を実装せねばならないし、直感的なものにはできなさそう）

### 永続化

　栞で永続化するときIndexedDBでないとダメだと思う。localStorageは文字列のみ保存可能だが、IndexedDBはHTML要素型なども保存できたはず。なので今回、画面先頭のHTML要素をそのまま保存したいため、IndexedDBを使用すべき。

　なんとかlocalStorageのみで対処しようと考えてみるも、難しい。次のようなアイデアがある。

* p要素の出現順序を保存する
* p要素のInnerTextの内容を保存する

#### p要素の出現順序を保存する

　次のようにしてp要素の出現順序から識別する方法。だが、縦書きだと左上から順にはじまるため、出現順序が横書きのときと変わってしまう。おそらくコンピュータ・グラフィクスの原点がディスプレイの左上から開始する慣例にもとづいていると思われる。あるいは英語圏の常識である左上を縦書きのときも変えることなく流用しているのだろう。縦書きの処理はいまだにボロボロで完璧とは程遠い。細かいアラが目立つ。

```javascript
const index = 0;
for (const p of document.querySelectorAll('p')) {
    p.setAttribute('id', `p-${index}`);
    index += 1;
}
```

#### p要素のInnerTextの内容を保存する
 
　もし全くおなじテキスト内容のp要素が複数あったら特定できなくなる。レアケースだろうが、強調するためにあえて同じことを繰り返し表現することはある。この方法では特定できない場合が生じてしまうであろうことから却下する。
