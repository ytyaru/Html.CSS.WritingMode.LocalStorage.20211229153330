# 0.99 パフォーマンス考察

　CSSによる再計算、再描画が重い。なのでこれを最小化する必要がある。HTML要素やCSS変数の変更によって再計算・再描画される。よってそれらを最小化する必要がある。

* [大きく複雑なレイアウトとレイアウト スラッシングの回避](https://developers.google.com/web/fundamentals/performance/rendering/avoid-large-complex-layouts-and-layout-thrashing?utm_source=devtools#avoid-forced-synchronous-layouts)
* [スタイル計算のスコープと複雑さの軽減](https://developers.google.com/web/fundamentals/performance/rendering/reduce-the-scope-and-complexity-of-style-calculations)
* [JavaScript 実行の最適化](https://developers.google.com/web/fundamentals/performance/rendering/optimize-javascript-execution)

　このツールは本のように表示するものである。本は文庫本であれば10万字ほどある。もしこれらを一気にロードしたら初回ロード時の待機時間はどれほどになるだろうか。おそらく数十秒かかるだろう。まったく使い物にならないといっていい。

　体感時間を早めたい。初回ロード時、本文のデータは一切読み込まずにUI作成のみに専念する。LocalStorageやIndexedDBから読み取り、それをDOMにセットするのが主な処理だ。このとき開始時は`content-visibility:hidden;`にしておき、ロード完了直後に`visible`にする。

　気にするべきタイミングは以下だろう。

タイミング|理想
----------|----
初回ロード|最初に最速で[スケルトン][]を表示する。次に遅くとも2秒以内に1画面分のコンテンツを表示する。
ページ遷移|一瞬でページ遷移できること。１ページ読むのに1分は必要だろう。その間にバックグラウンドで次ページ以降のデータをロードする。
バックグラウンド|重い処理を常に走らせる。小さい仕事を短いスパンで何度も完了させ、徐々に完成させてゆく。

[スケルトン]:https://element-plus.org/en-US/component/skeleton.html

　具体的な実装方法は以下の通り。

1. 大きなひとつの処理を複数の小さな処理に小分けにする（マイクロタスク）
2. 各タスクはWeb Worker APIで非同期実行する
3. その結果を`requestAnimationFrame()`でディスプレイのフラッシュレートにあわせて最速表示する

　技術的には以下２点を使う。

* `requestAnimationFrame()`（`setInterval()`の代わりに使用）
* Web Worker API

　コード例は以下。

```javascript
var dataSortWorker = new Worker("sort-worker.js");
dataSortWorker.postMesssage(dataToSort);

// The main thread is now free to continue working on other things...

dataSortWorker.addEventListener('message', function(evt) {
   var sortedData = evt.data;
   // Update data on screen...
});
```

```javascript
var taskList = breakBigTaskIntoMicroTasks(monsterTaskList);
requestAnimationFrame(processTaskList);

function processTaskList(taskStartTime) {
  var taskFinishTime;

  do {
    // Assume the next task is pushed onto a stack.
    var nextTask = taskList.pop();

    // Process nextTask.
    processTask(nextTask);

    // Go again if there’s enough time to do the next task.
    taskFinishTime = window.performance.now();
  } while (taskFinishTime - taskStartTime < 3);

  if (taskList.length > 0)
    requestAnimationFrame(processTaskList);

}
```

* [たった一行で重いスクロールが軽快に！will-change属性を付けるとFPSが上がる理由](https://qiita.com/ttiger55/items/b2423cb72668c3c98d89)
* [will-change](https://developer.mozilla.org/ja/docs/Web/CSS/will-change)
